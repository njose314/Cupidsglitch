<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cupid's Glitch // Final Audio Fix</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #050505;
            color: #fff;
            overflow: hidden;
            font-family: 'Press Start 2P', monospace;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        /* CRT Effects */
        .scanlines {
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px;
            position: absolute; inset: 0; pointer-events: none; z-index: 50;
        }
        
        .screen-glow {
            position: absolute; inset: 0;
            background: radial-gradient(circle, rgba(255,20,147,0.1) 0%, rgba(0,0,0,0.9) 100%);
            pointer-events: none; z-index: 40;
        }

        /* Glass UI */
        .glass-panel {
            background: rgba(20, 20, 20, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 20, 147, 0.5);
            box-shadow: 0 0 15px rgba(255, 20, 147, 0.2);
        }

        .glass-toast {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(6px);
            border-top: 2px solid #ffd700;
            border-bottom: 2px solid #ffd700;
        }

        .neon-text { text-shadow: 0 0 10px #ff1493, 0 0 20px #ff1493; }
        
        /* Floating Quote Toast */
        #quoteToast {
            transition: opacity 0.5s ease, transform 0.5s ease;
            width: 90%;
            max-width: 400px;
        }

        canvas { display: block; width: 100%; height: 100%; }
        .hidden { display: none !important; }
    </style>
</head>
<body class="h-dvh w-screen flex flex-col items-center justify-center relative bg-black">

    <div class="scanlines"></div>
    <div class="screen-glow"></div>
    <canvas id="gameCanvas"></canvas>

    <div id="hud" class="absolute top-4 left-4 right-4 flex justify-between z-30 hidden pointer-events-none">
        <div class="text-pink-500 text-[10px]">ENVELOPES: <span id="letterCount" class="text-white">0/10</span></div>
        <div class="text-pink-500 text-[10px]">HP: <span id="hpDisplay" class="text-white">â™¥â™¥â™¥</span></div>
    </div>

    <div id="quoteToast" class="absolute top-1/4 left-0 right-0 mx-auto text-center pointer-events-none z-50 opacity-0 transform translate-y-4">
        <p class="glass-toast text-yellow-300 text-[10px] leading-loose p-4 shadow-[0_0_15px_rgba(255,215,0,0.3)]" id="quoteText">
            "Locating heart signal..."
        </p>
    </div>

    <div id="startScreen" class="absolute inset-0 z-40 flex flex-col items-center justify-center bg-black/95 p-6 text-center">
        <h1 class="text-2xl text-pink-500 mb-6 neon-text">CUPID'S GLITCH</h1>
        
        <div class="glass-panel p-6 mb-8 max-w-sm text-left w-full">
            <h3 class="text-xs text-cyan-400 mb-4 border-b border-gray-700 pb-2">MISSION BRIEFING</h3>
            <ul class="text-[10px] text-gray-300 space-y-3 leading-relaxed list-disc pl-4">
                <li><strong class="text-pink-400">GOAL:</strong> Crack open <span class="text-white">10 Love Envelopes</span>.</li>
                <li><strong class="text-yellow-400">INTEL:</strong> Envelopes are TOUGH. Shoot them repeatedly to open!</li>
                <li><strong class="text-pink-400">CONTROLS:</strong> Drag to fly. Shooting is <span class="text-white">AUTOMATIC</span>.</li>
            </ul>
        </div>

        <button id="startBtn" class="glass-panel px-8 py-4 text-pink-400 text-xs uppercase active:scale-95 animate-pulse font-bold tracking-widest">
            START MISSION (WITH AUDIO)
        </button>
    </div>

    <div id="gameOverScreen" class="hidden absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/95 p-6 text-center overflow-y-auto">
        <div class="my-auto">
            <h2 id="goTitle" class="text-xl mb-4 neon-text"></h2>
            <div id="goMessage" class="text-[10px] text-gray-300 mb-8 leading-loose max-w-xs mx-auto"></div>
            <button id="restartBtn" class="glass-panel px-6 py-4 text-pink-400 text-xs uppercase active:scale-95">RESTART SYSTEM</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // UI Elements
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const hud = document.getElementById('hud');
        const letterDisplay = document.getElementById('letterCount');
        const hpDisplay = document.getElementById('hpDisplay');
        const quoteToast = document.getElementById('quoteToast');
        const quoteText = document.getElementById('quoteText');
        const goTitle = document.getElementById('goTitle');
        const goMessage = document.getElementById('goMessage');

        // --- INTERNAL AUDIO SYNTHESIZER (Guaranteed Sound) ---
        let audioCtx;
        let nextNoteTime = 0;
        let beatCount = 0;
        const TEMPO = 140; // Fast paced
        const SECONDS_PER_BEAT = 60.0 / TEMPO;
        const SCHEDULE_AHEAD_TIME = 0.1;

        function initAudio() {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
        }

        function playKick(time) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.setValueAtTime(150, time);
            osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
            gain.gain.setValueAtTime(1, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
            osc.start(time);
            osc.stop(time + 0.5);
        }

        function playSnare(time) {
            const bufferSize = audioCtx.sampleRate * 0.5;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 1000;
            const gain = audioCtx.createGain();
            
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            gain.gain.setValueAtTime(0.5, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
            noise.start(time);
        }

        function playBass(time, freq) {
            const osc = audioCtx.createOscillator();
            osc.type = 'sawtooth';
            const gain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);

            osc.frequency.setValueAtTime(freq, time);
            filter.frequency.setValueAtTime(1000, time);
            filter.frequency.exponentialRampToValueAtTime(100, time + 0.2); 
            
            gain.gain.setValueAtTime(0.2, time);
            gain.gain.linearRampToValueAtTime(0, time + 0.2);
            osc.start(time);
            osc.stop(time + 0.2);
        }

        function playHighSynth(time, freq) {
            const osc = audioCtx.createOscillator();
            osc.type = 'square';
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.setValueAtTime(freq, time);
            gain.gain.setValueAtTime(0.05, time);
            gain.gain.linearRampToValueAtTime(0, time + 0.1);
            osc.start(time);
            osc.stop(time + 0.1);
        }

        function scheduler() {
            while (nextNoteTime < audioCtx.currentTime + SCHEDULE_AHEAD_TIME) {
                scheduleNote(beatCount, nextNoteTime);
                nextNoteTime += SECONDS_PER_BEAT / 4; 
                beatCount++;
            }
            if(state.running) setTimeout(scheduler, 25);
        }

        function scheduleNote(beat, time) {
            const step = beat % 16;
            // Kick: 0, 4, 8, 12
            if (step % 4 === 0) playKick(time);
            // Snare: 4, 12
            if (step === 4 || step === 12) playSnare(time);
            
            // Driving Bassline (C Minor: C, Eb, G, Bb)
            const bassNote = [65.41, 65.41, 77.78, 65.41, 51.91, 51.91, 58.27, 65.41];
            if (step % 2 === 0) playBass(time, bassNote[Math.floor(beat/4)%8]);

            // High arpeggio
            if (step % 3 === 0) playHighSynth(time, 523.25 + (step * 50));
        }

        // --- ASSETS ---
        const ALL_QUOTES = [
             "Are you a keyboard? Because you're my type.",
            "You auto-complete me.",
            "My heart has zero latency with you.",
            "I'd never delete your cookies.",
            "You're the CSS to my HTML.",
            "Overclocking my heart...",
            "Status: 100% In Love.",
            "You are my favorite notification.",
            "Are you Wi-Fi? I'm feeling a connection.",
            "You make my floppy disk a hard drive.",
            "Is your name Google? You have everything I search for.",
            "You had me at 'Hello World'.",
            "My love for you is infinite loop.",
            "You are the root user of my heart.",
            "I want to Ctrl+S you forever.",
            "Are you a glitch? Because I can't take my eyes off you.",
            "You update my software automatically.",
            "Let's pair our devices.",
            "You are my high score.",
            "I'm stuck in your orbit.",
            "Your smile renders perfectly.",
            "No firewall can stop my love.",
            "You are the only variable I need.",
            "Let's Git Commit to each other.",
            "You make my heart beat faster than 5G.",
            "I'd pause my game for you.",
            "You're hotter than my laptop running cyberpunk.",
            "Are you a GPU? Because you make everything look better.",
            "Love.exe has executed successfully.",
            "You're my Player 2.",
            "Let's sync our hearts.",
            "You're the missing pixel in my life.",
            "I'm laggy when you're not around.",
            "You have full admin rights to my heart.",
            "Your interface is beautiful.",
            "Let's connect on a deeper protocol.",
            "You charge my battery.",
            "I'm buffering... admiring you.",
            "Are you Bluetooth? I feel paired.",
            "You're the source code of my happiness.",
            "System Overload: Too much cute.",
            "I'd reboot my life for you.",
            "You're my home page.",
            "Let's encrypt our love.",
            "You're 4K resolution in a 1080p world.",
            "My love bandwidth is unlimited for you.",
            "You're the master key to my heart.",
            "I'm detecting high levels of attraction.",
            "You're my daily reward.",
            "Are you a magnet? I'm attracted.",
            "Let's make some memories in the cloud.",
            "You're better than free Wi-Fi.",
            "I'd trade all my loot for a kiss.",
            "You're the glitch I never want to fix.",
            "My heart runs on your OS.",
            "You're the unexpected update I needed.",
            "Let's go AFK together.",
            "You're my favorite algorithm.",
            "I'm scanning for your love.",
            "You're the logic to my chaos.",
            "I'm compiled just for you.",
            "Let's build a life stack.",
            "You're the best feature, not a bug.",
            "I'm hardcoded to love you.",
            "You make my fans spin fast.",
            "Are you a touchscreen? I want to hold you.",
            "You're the VIP in my server.",
            "Let's duo queue for life.",
            "You're my ultimate ability.",
            "I'm farming XP (Xtra Passion) for you.",
            "You're a legendary drop.",
            "My ping is 0 when I'm with you.",
            "You're the graphics card to my display.",
            "I'd rage quit the world for you.",
            "You're the save point in my day.",
            "Let's level up together.",
            "You're the cheat code to happiness.",
            "I'm streaming my love to you.",
            "You're the best skin in the game.",
            "My heart has a dedicated server for you.",
            "You're the raid boss of beauty.",
            "Let's mod this world together.",
            "You're the expansion pack to my life.",
            "I'm gridlocked on you.",
            "You're the syntax to my sugar.",
            "I'd debug your code any day.",
            "You're the kernel of my OS.",
            "I'm overflowing with love.",
            "You're the binary to my soul.",
            "Let's run a diagnostic on our love (Result: Perfect).",
            "You're the cache I never clear.",
            "I'm hooked on your API.",
            "You're the bandwidth to my heart.",
            "I'm formatted for you.",
            "You're the patch note I waited for.",
            "Let's initiate the cuddle protocol.",
            "You're the verified tick in my life.",
            "I'm subscribing to your heart.",
            "You're the notification I wait for."
        ];
        let gameQuotes = [];

        const COLORS = {
            player: '#ff1493',
            bullet: '#ff69b4',
            enemy: '#ff0000',
            letter: '#ffffff',
            bg: '#050505'
        };

        // Entities
        let player = { x: 0, y: 0, w: 32, h: 32, hp: 3 };
        let bullets = [];
        let enemies = [];
        let collectibles = [];
        let particles = [];
        let stars = [];

        // State
        let state = {
            running: false,
            won: false,
            score: 0,
            letters: 0,
            frameCount: 0,
            lastTime: 0,
            slowMo: 0
        };

        // Input
        let touchActive = false;
        let inputX = 0, inputY = 0;
        const TOUCH_OFFSET_Y = 75; 

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if(!state.running) {
                // Initial: Center, 80% down
                player.x = canvas.width / 2;
                player.y = canvas.height * 0.8;
            }
        }
        window.addEventListener('resize', resize);
        resize();

        // --- INPUT ---
        function updateInput(x, y) {
            const rect = canvas.getBoundingClientRect();
            inputX = x - rect.left;
            inputY = y - rect.top;
            touchActive = true;
        }
        canvas.addEventListener('touchstart', e => { e.preventDefault(); updateInput(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});
        canvas.addEventListener('touchmove', e => { e.preventDefault(); updateInput(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});
        canvas.addEventListener('touchend', () => touchActive = false);
        canvas.addEventListener('mousedown', e => updateInput(e.clientX, e.clientY));
        canvas.addEventListener('mousemove', e => { if(touchActive) updateInput(e.clientX, e.clientY); });
        canvas.addEventListener('mouseup', () => touchActive = false);

        // --- GAME LOGIC ---

        function shuffleQuotes() {
            gameQuotes = [...ALL_QUOTES].sort(() => 0.5 - Math.random()).slice(0, 15);
        }

        function spawnEnemy() {
            const size = 30;
            enemies.push({
                x: Math.random() * (canvas.width - size),
                y: -50,
                w: size, h: size,
                speed: 3 + Math.random() * 2,
                hp: 1,
                angle: 0
            });
        }

        function spawnEnvelope() {
            const size = 50; // Bigger target
            collectibles.push({
                x: Math.random() * (canvas.width - size),
                y: -50,
                w: size, h: size * 0.7,
                speed: 1.5, // Slower
                wobbleOffset: Math.random() * 100,
                hp: 20, // HARD TO CRACK
                maxHp: 20,
                hitFlash: 0
            });
        }

        function triggerQuote() {
            state.slowMo = 90; 
            const quote = gameQuotes[state.letters % gameQuotes.length];
            quoteText.innerText = quote;
            quoteToast.style.opacity = '1';
            quoteToast.style.transform = 'translateY(0)';
            setTimeout(() => {
                quoteToast.style.opacity = '0';
                quoteToast.style.transform = 'translateY(10px)';
            }, 3000);
        }

        function winGame() {
            state.won = true;
            enemies = [];
            collectibles = [];
            
            // Fireworks
            for(let i=0; i<80; i++) {
                createParticle(canvas.width/2, canvas.height/2, COLORS.player, 15);
                createParticle(canvas.width/2, canvas.height/2, '#00ffff', 15);
            }
            if(navigator.vibrate) navigator.vibrate([100, 50, 100, 50, 200, 50, 500]);

            setTimeout(() => {
                state.running = false;
                hud.classList.add('hidden');
                gameOverScreen.classList.remove('hidden');
                goTitle.innerText = "HAPPY KISS DAY";
                goTitle.className = "text-2xl text-pink-500 mb-4 neon-text font-bold";
                goMessage.innerHTML = `
                    <span class="text-cyan-400">MISSION SUCCESS.</span><br><br>
                    I love you so much.<br>
                    Your kisses still give me real butterflies in this digital world.<br><br>
                    <span class="text-[8px] text-pink-700 italic">I love making these mini games ONLY and ONLY for you. ðŸ˜˜</span>
                `;
            }, 2500);
        }

        function createParticle(x, y, color, speedMult = 1) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 8 * speedMult,
                vy: (Math.random() - 0.5) * 8 * speedMult,
                life: 1.0,
                color: color
            });
        }

        function update(dt) {
            if (!state.running) return;

            let timeScale = 1;
            if (state.slowMo > 0) {
                timeScale = 0.2;
                state.slowMo--;
            }

            if (touchActive && !state.won) {
                let targetY = inputY - TOUCH_OFFSET_Y;
                player.x += (inputX - player.x) * 0.2;
                player.y += (targetY - player.y) * 0.2;
                player.x = Math.max(20, Math.min(canvas.width - 20, player.x));
                player.y = Math.max(20, Math.min(canvas.height - 20, player.y));
            } else if (state.won) {
                player.y -= 3;
                player.x += Math.sin(state.frameCount * 0.1) * 5;
            }

            // Fire
            if (touchActive && state.frameCount % 6 === 0 && !state.won) {
                bullets.push({ x: player.x, y: player.y - 20, w: 10, h: 10, speed: 12 });
                if(navigator.vibrate) navigator.vibrate(5);
            }

            bullets.forEach((b, i) => {
                b.y -= b.speed * timeScale;
                if (b.y < -20) bullets.splice(i, 1);
            });

            if (!state.won) {
                if (state.frameCount % Math.floor(40/timeScale) === 0) spawnEnemy();
                // Spawn envelopes: Check if few on screen
                if (collectibles.length < 1 && state.frameCount % 60 === 0) spawnEnvelope();
                else if (state.frameCount % Math.floor(200/timeScale) === 0) spawnEnvelope();
            }

            enemies.forEach((e, i) => {
                e.y += e.speed * timeScale;
                e.angle += 0.1;
                const dist = Math.hypot(player.x - (e.x + e.w/2), player.y - (e.y + e.h/2));
                if (dist < 30 && !state.won) {
                    player.hp--;
                    updateHP();
                    enemies.splice(i, 1);
                    createParticle(player.x, player.y, COLORS.player);
                    if(navigator.vibrate) navigator.vibrate(200);
                    if(player.hp <= 0) endGame();
                }
                if (e.y > canvas.height) enemies.splice(i, 1);
            });

            collectibles.forEach((c, i) => {
                c.y += c.speed * timeScale;
                c.x += Math.sin((c.y + c.wobbleOffset) * 0.05) * 1.5; 
                if(c.hitFlash > 0) c.hitFlash--;

                bullets.forEach((b, bIdx) => {
                    if (b.x > c.x && b.x < c.x + c.w && b.y > c.y && b.y < c.y + c.h) {
                        // Hit Envelope
                        c.hp--;
                        c.hitFlash = 5;
                        c.w -= 0.5; // Shrink slightly
                        c.h -= 0.3;
                        
                        bullets.splice(bIdx, 1);
                        createParticle(b.x, b.y, '#fff', 0.5); // Sparks
                        
                        if (c.hp <= 0) {
                            // CRACK OPEN
                            state.letters++;
                            letterDisplay.innerText = state.letters + "/10";
                            createParticle(c.x + c.w/2, c.y + c.h/2, COLORS.letter, 2);
                            if(navigator.vibrate) navigator.vibrate([30, 30, 30]);
                            triggerQuote();
                            collectibles.splice(i, 1);
                            if(state.letters >= 10) winGame();
                        }
                    }
                });
                if (c.y > canvas.height) collectibles.splice(i, 1);
            });

            // Bullets vs Enemies
            bullets.forEach((b, bIdx) => {
                enemies.forEach((e, eIdx) => {
                    if (b.x > e.x && b.x < e.x + e.w && b.y > e.y && b.y < e.y + e.h) {
                        enemies.splice(eIdx, 1);
                        bullets.splice(bIdx, 1);
                        createParticle(e.x + e.w/2, e.y + e.h/2, COLORS.enemy);
                    }
                });
            });

            particles.forEach((p, i) => {
                p.x += p.vx * timeScale;
                p.y += p.vy * timeScale;
                p.life -= 0.05;
                if (p.life <= 0) particles.splice(i, 1);
            });

            stars.forEach(s => {
                s.y += s.speed * timeScale;
                if (s.y > canvas.height) {
                    s.y = 0;
                    s.x = Math.random() * canvas.width;
                }
            });
        }

        // --- DRAWING ---
        function drawHeart(x, y, size, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            let topCurveHeight = size * 0.3;
            ctx.moveTo(x, y + topCurveHeight);
            ctx.bezierCurveTo(x, y, x - size / 2, y, x - size / 2, y + topCurveHeight);
            ctx.bezierCurveTo(x - size / 2, y + (size + topCurveHeight) / 2, x, y + (size + topCurveHeight) / 2, x, y + size);
            ctx.bezierCurveTo(x, y + (size + topCurveHeight) / 2, x + size / 2, y + (size + topCurveHeight) / 2, x + size / 2, y + topCurveHeight);
            ctx.bezierCurveTo(x + size / 2, y, x, y, x, y + topCurveHeight);
            ctx.closePath();
            ctx.fill();
        }

        function drawEnvelope(c) {
            let x = c.x, y = c.y, w = c.w, h = c.h;
            
            // Flash white on hit
            ctx.fillStyle = c.hitFlash > 0 ? '#fff' : '#eee';
            
            // Shake effect
            if (c.hitFlash > 0) {
                x += (Math.random() - 0.5) * 4;
            }

            ctx.fillRect(x, y, w, h);
            
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + w/2, y + h/1.5);
            ctx.lineTo(x + w, y);
            ctx.stroke();

            drawHeart(x + w/2, y + h/1.5 - 5, 10, '#ff0000');
            
            // Health Bar Mini
            if (c.hp < c.maxHp) {
                ctx.fillStyle = 'red';
                ctx.fillRect(x, y - 5, w, 3);
                ctx.fillStyle = '#0f0';
                ctx.fillRect(x, y - 5, w * (c.hp / c.maxHp), 3);
            }
        }

        function draw() {
            ctx.fillStyle = COLORS.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            stars.forEach(s => ctx.fillRect(s.x, s.y, s.size, s.size));

            if(state.running || state.won) {
                if(touchActive && !state.won) {
                    ctx.strokeStyle = 'rgba(255, 20, 147, 0.2)';
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(player.x, player.y + 20);
                    ctx.lineTo(inputX, inputY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                ctx.shadowBlur = 20;
                ctx.shadowColor = COLORS.player;
                drawHeart(player.x, player.y - 15, 30, COLORS.player);
                ctx.shadowBlur = 0;
            }

            bullets.forEach(b => drawHeart(b.x, b.y, 10, COLORS.bullet));

            enemies.forEach(e => {
                ctx.fillStyle = COLORS.enemy;
                ctx.save();
                ctx.translate(e.x + e.w/2, e.y + e.h/2);
                ctx.rotate(Math.sin(e.angle)*0.2);
                ctx.fillRect(-e.w/2, -e.h/2, e.w, e.h);
                ctx.fillStyle = '#000';
                ctx.fillRect(-e.w/4, -e.h/4, 5, 5);
                ctx.fillRect(e.w/4 - 5, -e.h/4, 5, 5);
                ctx.restore();
            });

            collectibles.forEach(c => drawEnvelope(c));

            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.fillRect(p.x, p.y, 4, 4);
                ctx.globalAlpha = 1.0;
            });
        }

        function loop(timestamp) {
            const dt = timestamp - state.lastTime;
            state.lastTime = timestamp;
            state.frameCount++;
            update(dt);
            draw();
            requestAnimationFrame(loop);
        }

        // --- STATE ---
        function init() {
            stars = [];
            for(let i=0; i<60; i++) {
                stars.push({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    size: Math.random() * 2,
                    speed: 0.5 + Math.random() * 3
                });
            }
            player.x = window.innerWidth / 2;
            player.y = window.innerHeight * 0.8;
        }

        function startGame() {
            initAudio();
            if(audioCtx.state === 'suspended') audioCtx.resume();
            beatCount = 0;
            nextNoteTime = audioCtx.currentTime + 0.1;
            scheduler();

            shuffleQuotes();
            state.running = true;
            state.won = false;
            state.score = 0;
            state.letters = 0;
            player.hp = 3;
            bullets = [];
            enemies = [];
            collectibles = [];
            
            player.x = canvas.width / 2;
            player.y = canvas.height * 0.8;
            
            letterDisplay.innerText = "0/10";
            updateHP();
            
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            hud.classList.remove('hidden');
        }

        function endGame() {
            state.running = false;
            hud.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');
            goTitle.innerText = "HEARTBROKEN";
            goTitle.className = "text-xl text-red-500 mb-4 neon-text";
            goMessage.innerText = "THE GLITCH WON. TRY AGAIN.";
            if(navigator.vibrate) navigator.vibrate(300);
        }

        function updateHP() {
            hpDisplay.innerText = "â™¥".repeat(player.hp);
        }

        init();
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', startGame);
        requestAnimationFrame(loop);

    </script>
</body>
</html>
